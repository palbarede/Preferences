# .screenrc
# =========

# SCREEN SETTINGS
# ===============

# Setta un escape alternativo: ^f
# escape ^ff
# ... ma anche una cosa tipo escape ``

# UTF-8 Support
defutf8 on

# activity on window X
activity "C'e' uno che te vole sulla %n"

# autodetach on HUP (when shell exit)
autodetach on

# bell msg
bell_msg '*knock* *knock* Follow the white rabbit in window %n'

# l'underline diventa cyan
# 30/11/2008 - anche questo non ha senso. quando lo avra' lo riabilitero'
# attrcolor u "-u c"

# comprime le righe vuote nel backlog
compacthist on

# quando incolla usa \n\r invece del solo \n
#crlf on

# ignore il case nelle ricerche di testo
ignorecase on

# mmmh...
# obuflimit [limit]
#
# If the output buffer contains more bytes than the specified  limit,  no
# more  data  will be read from the windows. The default value is 256. If
# you have a fast display (like xterm), you can set  it  to  some  higher
# value. If no argument is specified, the current setting is displayed.

# cose interessanti
#
#	!:sed -n s/.*Error.*/\007/p
# Sends  window  output  to  both,  the user and the sed command. The sed
# inserts an additional bell character (oct. 007) to  the  window  output
# seen  by screen.  This will cause "Bell in window x" messages, whenever
# the string "Error" appears in the window.
# (e' un comando, si da con ^A: !:sed...)

# Una "status bar" con l'elenco delle window e il loro nome, hostname e colori
# caption always "%{Yk}%H%{G}|%{C} %-Lw( %{W}%n%f %t%{-} )%+Lw %=%{G}|%{W}%d/%m/%y %D %c"
# Una "status bar" con l'elenco delle window e il loro nome, nero su bianco
#caption always "%{= wk} %?%-Lw%?%{= kd} %n*%f %t %{= wk}%?%+Lw%? %{= wk}%=%{= Wk} %C%a %d-%m-%Y %{= wk}"

# quella giusta:
# caption always "%{= kR} %?%-Lw%?%{= bk} %n*%f %t %{= kR}%?%+Lw%? %{= kR}%=%{= kw} %C%a %d-%m-%Y %{= kd}"

caption splitonly "%?%F%{.R.}%?%3n %t%? [%h]%?%= %C%a"
hardstatus string "%{= kw}%-Lw%{= BW}%50>%n%f* %t%{-}%+Lw %=%20`%d %M %Y, %10`"

backtick 10 	60	60		$HOME/bin/fuzzyclock.zsh
backtick 20	60	60		$HOME/Preferences/screen/load

# shelltitle '% |zsh'

# scrollback per window (5000 lines)
defscrollback 5000

# invoked shell
#shell /bin/zsh

# silence wait time (^C+A + _)
silencewait 20

# Il colore testo/colore sfondo dei messaggi di screen
sorendition kB

# initial banner
startup_message off

# visual bell on
vbell on

# visual bell msg
vbell_msg " -- SANTA POLENTA! -- "

# Messaggi stile nethack
nethack on

# di default cambia dir a $HOME
chdir

# 256 COLORS
# http://www.nabble.com/vim,-screen,-rxvt-unicode-and-colors-td20187494.html
# terminfo and termcap for nice 256 color terminal
# 1) allow bold colors - necessary for some reason
attrcolor b ".I"
# 2) tell screen how to set colors. AB = background, AF=foreground
termcapinfo xterm 'Co#256:AB=\E[48;5;%dm:AF=\E[38;5;%dm'
termcapinfo urxvt 'Co#256:AB=\E[48;5;%dm:AF=\E[38;5;%dm'
# 3) erase background with current bg color (cambia TERM in screen-bce, su obsd e' male)
#    Change background-color-erase setting. If "bce" is set to on, all
#    characters  cleared  by  an erase/insert/scroll/clear operation will be
#    displayed in the current background color. Other- wise the default
#    background color is used.
# defbce on 

# ------------------------------------------------------------------------------
# SCREEN KEYBINDINGS
# ------------------------------------------------------------------------------

# F8 / ALT+RIGHT = next window
bindkey -k k9 next
bindkey "^[[1;3C" next
# rxvt (funziona?)
bindkey "^[^[OC" next
# urxvt (funziona.)
bindkey "^[^[[C" next

# F9 / ALT+LEFT = prev window
bindkey -k k8 prev
bindkey "^[[1;3D" prev
# rxvt (funziona?)
bindkey "^[^[OD" prev
# urxvt (funziona.)
bindkey "^[^[[D" prev

# NOTA: come trovare gli escape su urxvt:
# con lo Xdefaults attuale (commit 46d65dca6c24429624b795cd4f84ccbacfcfaf56)
# bisogna lanciare urxvt SENZA SCREEN e usare la mia
# funzione raw_kb().

# prova
#bindkey "^[<" eval number !echo $WINDOW-1|bc
#bindkey "^[>" eval number !echo $WINDOW+1|bc

# Remove some stupid / dangerous key bindings
bind ^k
#bind L
bind ^\
# Make them better
bind \\ quit
bind K kill
#bind I login on
#bind O login off
bind } history

# window resize with = + -
bind = resize =
bind + resize +3
bind - resize -3

# muoversi tra aree della stessa finestra
bind ^j focus down
bind ^k focus up
bind ^t focus top
bind ^b focus bottom


# ------------------------------------------------------------------------------
# TERMINAL SETTINGS
# ------------------------------------------------------------------------------

# da debian -->
# The vt100 description does not mention "dl". *sigh*
#termcapinfo vt100 dl=5\E[M

# - Il titolo della finestra xterm/urxvt/etc...

# uso la hardstatus per il titolo dell'xterm, quindi non voglio messaggi
# (leggi la man per capire questo oscuro messaggio).
hardstatus alwayslastline

# Set the hardstatus prop on gui terms to set the titlebar/icon title
#termcapinfo xterm*|rxvt*|kterm*|Eterm* hs:ts=\E]0;:fs=\007:ds=\E]0;\007

# screen NUMERO (TITOLO) | user@host
defhstatus "screen ^E (^Et) | $USER@^EH"

# set these terminals up to be 'optimal' instead of vt100
# termcapinfo xterm*|linux*|rxvt*|Eterm* OP

# Change the xterm initialization string from is2=\E[!p\E[?3;4l\E[4l\E>
# (This fixes the "Aborted because of window size change" konsole symptoms found
#  in bug #134198)
#termcapinfo xterm 'is=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;4;6l'

# Enable non-blocking mode to better cope with flaky ssh connections.
defnonblock 5
#defnonblock off

# http://aperiodic.net/screen/faq
#
# First off, it's recommended that you use screen's scrollback buffer instead.
# Since you can have multiple windows in a screen session, if you switch
# between those windows, your terminal scrollback will mix lines from all of
# those windows, but screen keeps separate scrollback buffers for each one.
# Just use C-a ESC or C-a [ to enter copy mode. But if you do want scrollback
# in your terminal window (usually xterm), read on.
# 
# Some background: One capability that a terminal may have is an “alternate
# screen”. xterm has it, and you may have seen its effects–a program will
# request the alternate screen, the terminal switches there, and when the
# program exits the terminal goes back to the normal screen, leaving all the
# text there intact.  It is recommended that all full-screen apps use this, so
# as to minimize their impact on any purely command-line stuff. It makes sense,
# for instance, for vi to use the alternate screen. The drawback to the
# alternate screen is that only the main screen accumulates scrollback.
#
# As you might have guessed, screen uses the alternate screen, if it’s
# available. There’s no real way to turn off use of the alternate screen, but
# you can make screen think that the terminal doesn’t have an alternate screen
# with the termcapinfo command:
# termcapinfo xterm* ti@:te@

# To get screen to add lines to xterm's scrollback buffer, uncomment the
# following termcapinfo line which tells xterm to use the normal screen buffer
# (which has scrollback), not the alternate screen buffer.

# *NOTA* 30/11/2008
# Non ha molto senso usare lo scrollback di xterm (o gnome-terminal), perche'
# viene intaccato dagli altri screen
# termcapinfo xterm*|xterms|xs|rxvt ti@:te@



# ------------------------------------------------------------------------------
# STARTUP SCREENS
# ------------------------------------------------------------------------------

# Example of automatically running some programs in windows on screen startup.
#
#   The following will open top in the first window, an ssh session to monkey
#   in the next window, and then open mutt and tail in windows 8 and 9
#   respectively.
#
# screen top
# screen -t monkey ssh monkey
# screen -t mail 8 mutt
# screen -t daemon 9 tail -f /var/log/daemon.log
