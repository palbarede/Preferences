# ==============================================================
# ~/.zsh/zcomp
# Completion della ZSH, perche' la pigerrimitudo e' una virtute.
# --------------------------------------------------------------
#
# :completion:function:completer:command:argument:tag

# compinstall, dilemma TODO
zstyle :compinstall filename '~/.zsh/main'

# questo va all'inizio, altrimenti poi non ho `compdef` o altri comandi.
autoload -Uz compinit && compinit

# supporto bash completion (da chiamare DOPO 'compinit')
autoload -Uz bashcompinit && bashcompinit

# Lista di completers
# _prefix deve stare prima di _approximate, senno' e' OLOCAUSTO
# _ignored completa file/dir che per altre impostazioni verrebbero ignorati
#zstyle ':completion:::::' completer _complete _prefix _approximate _ignored

# Forza il rehash per ogni uso della completion (ie: premi tab).
# http://zshwiki.org/home/examples/compquickstart?s=rehash
_force_rehash() {
	(( CURRENT == 1 )) && rehash
	return 1	# Because we didn't really complete anything.
}
zstyle ':completion:*' rehash true	# rehash automatico, ma non sembra funzionare... TODO

# Abilita i messaggi della completion, aggiunge bold ad alcune stringhe
# e raggruppa i risultati per tipologia (fidati, e' MEGLIO COSI')
zstyle ':completion:*:messages' format %d
zstyle ':completion:*:warnings' format '%BNo matches%b: %d'
zstyle ':completion:*:descriptions' format '%B%d%b'
# raggrouppa l'output
zstyle ':completion:*' group-name ''
zstyle ':completion:*' list-separator '-->'
# Non completare i nomi delle funzioni che iniziano per '_'
#zstyle ':completion::complete:*:functions' ignored-patterns '_*'
# che sia cosi'?
zstyle ':completion:*:functions' ignored-patterns '_*'



# separa i man per sezione
zstyle ':completion:*:manuals' separate-sections true

# Mostra le descrizioni per cio' che viene completato, ad esempio le opzioni di ls;
# quando manca la descrizione, prova a "indovinare"
zstyle ':completion:*' verbose yes
zstyle ':completion:*' auto-description 'specify: %d'

# Utilizza un pager interno quando i risultati della completion sono troppi
zstyle ':completion:*:default' list-prompt '%S%M matches%s'
bindkey -M listscroll q send-break	# binda 'q' per uscire dal pager

# Limit this fuckung "zsh: do you wish to see all NNN possibilities (NNN
# lines)?" downward (default is 100). Only ask before displaying
# completions if doing so would scroll. (strcat.de)
#LISTMAX=0

# Completion approssimativa, permette un errore ogni 3 caratteri
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'
zstyle ':completion:::::' completer _force_rehash _complete _prefix _approximate _ignored
zstyle -e ':completion:*:approximate:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/3 ))numeric)'
# Completa cose tipo: gzip _-d -> gzip --decompress
zstyle ':completion::approximate*:*' prefix-needed false

# Case insensitive: converte solo le minuscole in maiuscole, perche' come dicono
# NEL LIBRO, per scrivere le maiuscole devi premere anche shift, ed e' quindi piu'
# probabile che sia una scelta deliberata e non un errore di battitura
# INOLTRE, implementa la Partial Completion, usando '/' come carattere anchor: cio'
# permette finezze come cd /u/l/b -> cd /usr/local/bin -- e' come premere TAB su ogni
# '/'
zstyle ':completion:*:(^approximate):*' matcher-list \
	'r:|[/]=* r:|=* m:{a-z}={A-Z}'

# titoli [from: https://github.com/seebi/zshrc]
zstyle ':completion:*:messages' format $'\e[01;35m -- %d -- \e[00;00m'
zstyle ':completion:*:warnings' format $'\e[01;31m -- No Matches Found -- \e[00;00m'
zstyle ':completion:*:descriptions' format $'\e[01;33m -- %d -- \e[00;00m'
zstyle ':completion:*:corrections' format $'\e[01;33m -- %d -- \e[00;00m'

# statusline for many hits [from: https://github.com/seebi/zshrc]
zstyle ':completion:*:default' select-prompt $'\e[01;35m -- Match %M %P -- \e[00;00m'

# Prefix Completion: se il cursore e' nel mezzo di una word, zsh completa come se il
# cursore si trovasse a fine word; l'opposto si ottiene abilitando complete_in_word.
# Un altro approccio consiste nel completare ignorando completamente il suffix...
zstyle ':completion::prefix:::' completer _complete
zstyle ':completion:*:prefix:*' add-space true	# aggiunge anche uno spazio

# Esclusioni
# Avendo '_ignored' tra i completer, le seguenti regole verranno ignorate nel caso
# in cui non ci sia altro da completare
zstyle ':completion:*:*:cd:*' ignored-patterns '(*/|)(CVS)'
# Evita di completare cio' che e' gia' sulla command line
# Questo e' AAAH, sputtana la completion e il Tab non cycla piu' tra i possibili match :-(
#zstyle ':completion:*:(rm|rmdir|grep|vim|vi):*' ignore-line true
# Non completare le directory se la completion "non ha senso" (../$PWD non ha senso)
#zstyle ':completion:*' ignore-parents parent pwd
# meglio?
zstyle ':completion:*:cd:*' ignore-parents parent pwd
# Per abilitare la completion di "cd ../"
zstyle ':completion:*' special-dirs true


# Completa cio' che non ESISTE, UN FILM DI ZARRO SUCUNI
zstyle ':completion::*:(-command-|export):*' fake-parameters DISPLAY:scalar \
    LD_LIBRARY_PATH:array COLUMNS:scalar LANG:scalar LC_ALL:scalar CVSROOT:scalar \
    PERL5LIB:array PYTHONPATH:array DJANGO_SETTINGS_MODULE:scalar \
    SSH_AUTH_SOCK:scalar DYLD_LIBRARY_PATH:array DYLD_FALLBACK_LIBRARY_PATH:array

# Completion per `kill`: mostra una lista di processi con la percentuale di CPU
# utilizzata, e su linux come bonus mostra i processi come un albero
# gerarchico.
if [[ $OSTYPE == linux* ]]; then
	zstyle ':completion::*:kill:*:*' command 'ps xf -U $USER -o pid,%cpu,%mem,cmd'
else
	# -r -- sort by CPU usage
	zstyle ':completion:*:processes' command 'ps x -U $USER -r -o pid,%cpu,%mem,tt,args'
fi
# ... e ovviamente i colori. [from: https://github.com/seebi/zshrc]
zstyle ':completion::*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;32'

# cache
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/.zcompcache

# Completion con i colori di ls
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# completion from history [ https://github.com/seebi/zshrc/blob/master/options.zsh ]
zle -C hist-complete complete-word _generic
zstyle ':completion:hist-complete:*' completer _history
bindkey '^X^X' hist-complete

# Ctrl-X - SHIFT+S
# Completa usando le parole della schermata attuale di tmux.
# da zsh-lovers.
_complete_screen_display() {
	#[[ "$TERM" != screen* ]] && return 1

	if (( $+commands[gmktemp] )); then
		local TMPFILE=$(gmktemp)
	else
		local TMPFILE=$(mktemp)
	fi
	local -U -a _screen_display_wordlist
	trap "rm -f $TMPFILE" EXIT

	if ((${+TMUX})); then
		tmux -V &>/dev/null || return
		tmux -q capture-pane \; save-buffer -b 0 $TMPFILE \; delete-buffer -b 0
	else
		echo "eh no"
		return
	fi
	_screen_display_wordlist=( ${(QQ)$(<$TMPFILE)} )
	_screen_display_wordlist[${_screen_display_wordlist[(i)$PREFIX]}]=""
	compadd -a _screen_display_wordlist
}
bindkey -r "^XS"
compdef -k _complete_screen_display complete-word '^XS'

# completion per pip
function _pip_completion {
  local words cword
  read -Ac words
  read -cn cword
  reply=( $( COMP_WORDS="$words[*]" \
             COMP_CWORD=$(( cword-1 )) \
             PIP_AUTO_COMPLETE=1 $words[1] ) )
}
compctl -K _pip_completion pip

# completion bash per tmux
[[ -e /usr/local/etc/bash_completion.d/tmux ]] && source /usr/local/etc/bash_completion.d/tmux
# la completion di ack e' linux only :(
if [[ $OSTYPE == linux* ]]; then
	[[ -e /usr/local/etc/bash_completion.d/ack.bash_completion.sh ]] && source /usr/local/etc/bash_completion.d/ack.bash_completion.sh
fi

# vim: ft=zsh
