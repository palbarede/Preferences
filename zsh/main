# +----------------------------------------------------------------------------+
# |                                                                            |
# |            ,@@@@@@@@@,                                                     |
# |          @@@@@@@@@@@@@@@    EHY PACE FRATELLO, QUESTO E' IL FILE PRINCIPALE|
# |         @@@@@@@@@@@@@@@@@   DI ZSH AMICO, NIENTE PRESE A MALE! FUMIAMOCI   |
# |         @@@@@@@@@@@@@@@@@   LA GANJA E FOTTIAMOCENE IL CAZZO DI TUTTO,     |
# |         @@@@@'_   _'@@@@@  /     DAI !                                     |
# |          @@@| o   o |@@@                                                   |
# |           '@|  (_)  |@'                                                    |
# |             \  ___  /                                                      |
# |             |\_`~`_/|            zsh/main (ex .zshrc)                      |
# |        ____/:  `"`  :\____       opzioni, prompt, PATH, defaults...        |
# |      /`}}}}}\       /{{{{{`\                                               |
# |     /  {{{{{ \     / }}}}}  \                                              |
# |    /   }}}}}  \.-./  {{{{{   \                                             |
# |   |    {{{{{  / | \  }}}}}    |                                            |
#jgs  |    }}}}}  \/|\/  {{{{{    |                                            |
# |   |   /{{{{{   '-'   }}}}}\   |                                            |
# +----------------------------------------------------------------------------+


# Questo file viene eseguito solo quando la shell e'
# interattiva, quindi NO script, NO crontab, SI sadomaso.

# Opzioni di zsh globali {{{
# -------
setopt NO_beep				# Spegne il beep in ZLE
setopt auto_cd				# Entra nelle directory senza usare 'cd'
setopt auto_pushd			# Ficca $OLDPWD (dir precedente) nello stack delle dir
setopt check_jobs			# Avverte dei processi in background prima di killare la shell
setopt complete_in_word		# Completa nel mezzo delle word (altrimenti parte dalla fine)
setopt correct				# Corregge lo spelling dei comandi
setopt equals				# Permette =command al posto di `which command`
setopt extended_glob		# Usa '~', '^' e '#' per i pattern
setopt NO_flow_control		# Disabilita Ctrl-S e Ctrl-Q, ovvero il flow control, ovvero "ODDIO IL TERM Ãˆ FREEZATO!"
#setopt glob_complete		# Quando la word da completare contiene un glob pattern,
							# invece di inserire il risultato del glob, cicla tra i
							# risultati, come nella completion con  MENU_COMPLETE
setopt NO_hup				# Non manda -HUP ai processi quando la shell muore
setopt list_packed			# Completion list piu' piccola, con colonne di varia larghezza
setopt long_list_jobs		# Elenca i job nel formato esteso
setopt notify				# Avvisa subito dello status dei job in background, invece di
							# aspettare un nuovo prompt
setopt numeric_glob_sort	# Sort numerico per file contenenti numeri (a_00, a_01, ...)
setopt print_exit_value		# Printa l'exit value quando e' diverso da zero
setopt prompt_subst			# Esegue le varie expansion nel prompt (param expansions, command subst etc)
setopt pushd_ignore_dups	# Purga i duplicati dallo stack delle directory
#setopt pushd_silent		# Non printa lo stack delle dir dopo pushd o popd
setopt NO_rm_star_silent	# Chiede conferma per: 'rm *' o 'rm /path/*'
setopt short_loops			# Permette le forme abbreviate di for, if, function, etc...
setopt interactive_comments	# Permette di lasciare commenti sulla cmd line, utile con 'script'
setopt TRANSIENT_RPROMPT	# Remove any right prompt from display when accepting a command line. This may be useful with terminals with other cut/paste methods.
setopt REMATCH_PCRE			# Se possibile usa le PCRE per l'operatore =~

# Da valutare
# setop NO_clobber - il redirect '>' e '>>' fallisce se il file esiste giÃ ,
# bisognerebbe usare '>!' e '>>!'; Ã¨ interessante ma occhio che non sia attivo
# negli script!

# zsh 5.x utf-8
if [[ $ZSH_VERSION == <5->.* ]]; then
	setopt COMBINING_CHARS
fi

# }}}


# PROMPT
# ----------------------------------------....
#                           )/_
#                 _.--..---"-,--c_
#            \L..'           ._O__)_
#    ,-.     _.+  _  \..--( /           a:f
#      `\.-''__.-' \ (     \_
#        `'''       `\__   /\
#                    ')

autoload -U colors
colors

# Hostname colorati in base al loro hash # idea copiata para para da
# nickcolors.pl per irssi
colnames=(
	black
	red
	green
	yellow
	blue
	magenta
	cyan
	white
	default
)

for color in $colnames; do
	eval f$color='%{${fg[$color]}%}'
	eval b$color='%{${bg[$color]}%}'
done

# zsh/spectrum
# http://github.com/sykora/etc/blob/master/zsh/functions/spectrum/
typeset -Ag FX FG BG

FX=(
    reset     "%{[00m%}"
    bold      "%{[01m%}" no-bold      "%{[22m%}"
    italic    "%{[03m%}" no-italic    "%{[23m%}"
    underline "%{[04m%}" no-underline "%{[24m%}"
    blink     "%{[05m%}" no-blink     "%{[25m%}"
    reverse   "%{[07m%}" no-reverse   "%{[27m%}"
)

for color in {000..255}; do
    FG[$color]="%{[38;5;${color}m%}"
    BG[$color]="%{[48;5;${color}m%}"
done

function spectrum_ls() {
	for code in {000..255}; do
		print -P -- "$code: %F{$code}Test%f"
	done
}


# Hash the hostname and return a fixed "random" color
function hostname_color() {
	local chash=0
	foreach letter ( ${(ws::)HOST[(ws:.:)1]} )
		(( chash += #letter ))
	end
	local crand=$(( $chash % 9 ))
	local crandname=$colnames[$crand]
	echo "%{${fg[$crandname]}%}"
}


#PROMPT='[%T] $(hostname_color)%m${fdefault}%(1j.|%j.):%3c%# '
PROMPT='${fblue}[%T] ${fyellow}%3~ ${vcs_info_msg_0_}
$(hostname_color)%n${fdefault}@$(hostname_color)%m${fdefault}%(1j.|%j.) %# '

# Metto in RPROMPT l'exit value dell'ultimo comando se non e' 0
RPROMPT=$'%(?..%B${fred}âœ˜${fdefault} %?%b)'
# ci metto le info di git
#RPROMPT='${vcs_info_msg_0_}'

# Questo serve per costruire RPROMPT con le info di git
precmd () { vcs_info }

# Il prompt per lo spelling
# default: correct 'mano' to 'nano' [nyae]?
SPROMPT="zsh: correct '%R' to '%r' ? ([Y]es/[N]o/[E]dit/[A]bort) "

# NOTE PER IL PROMPT:
# - bisogna assegnare una stringa con apici SINGOLI, altrimenti le param. expansion NON funzionano!
# - come ${(%):-%~} ritorni $PWD a modo del prompt, e' MAGIA parameter expansion :)
## PROMPT='$FG[220][%T] in: $FX[bold]$FG[034]${${(%):-%~}//\//$FG[022]/$FG[034]}$FX[reset]%(0w#$FG[196] -> E DOMENICA! <-$FX[reset] #)
## %(1j.[%j] .)%(!.$FG[196]root .)$FG[245]%#$FX[reset] '

## RPROMPT="$FG[208]%n$FG[230]@$FG[075]%m$FX[reset]"

# Idee per path nel prompt colorato
# http://superuser.com/questions/49092/how-to-format-the-path-in-a-zsh-prompt


# ENVIRONMENT {{{
# -----------
# Queste variabili d'ambiente servono solo in modalita' interattiva
# Binda le seguenti variabili d'ambiente ai loro rispettivi array (ex: $perl5lib[@] )
declare -T LD_LIBRARY_PATH ld_library_path
declare -T PERL5LIB perl5lib
declare -T PYTHONPATH pythonpath

# La lingua tra le chiappe: LOCALE
# E' richiesto da iTerm (con UTF-8) e in generale e' il 2011 e direi che puo'
# anche diventare il mio cazzo di default.
# export LANG="en_US.UTF-8"
# !!! - 15 Nov 2011 - C'e' un po' di confusione, disattivo tutti i locale custom.
## export LANG="it_IT.UTF-8"
## export LC_MESSAGES="en_US.UTF-8"

# FTP in passive mode (CPAN)
export FTP_PASSIVE=1

# History
setopt append_history		# Appende al file $HISTORY, invece di sovrascrivere
setopt extended_history		# Salva i timestamp nella history
setopt hist_ignore_dups		# se il comando e' uguale al precedente non metterlo nella history
setopt hist_no_store		# non salvare nella history i comandi "history"
setopt hist_verify			# quando si usa la history expansion non esegue direttamente, cosi' vedi che stai per fare.
setopt hist_ignore_space	# non salva nella history le command line che iniziano con uno spazio (utile quando si inseriscono pw)
setopt hist_expire_dups_first	# cerca di cancellare dalla history i duplicati prima degli eventi unici
# February 21, 2013 - 2000 di history Ã¨ troppo poco, proviamo 12000 e vediamo
# che accade (che tra l'altro Ã¨ piÃ¹ di prima :-)
SAVEHIST=10000
HISTSIZE=12000

#HISTSIZE=2000
# 18-07-2012 - Scopro che forse e' questa history IMMENSA che mi causa uno
# startup molto lento per le nuove shell. Molti lo tengono uguale a HISTSIZE,
# ma questo significa che a conti fatti nel file history ci sara' solo la
# history dell'ultima shell chiusa, se e' stata molto utilizzata.
# SAVEHIST=10000
#SAVEHIST=2000
HISTFILE=$HOME/.history

# Opzioni per less
# -c	: pulisce lo schermo prima di mostrare il file
# -i	: ignore case (ma una ricerca uppercase annulla l'opzione)
# -M	: mostra percentuale del file ed e' piu' verboso di more
# -R	: attiva i colori ANSI
# -x<n> : lunghezza del tab
# -w	: Temporarily highlights the first "new" line after a forward movement of a full page.
# -J    : Mostra una 'status column' che indica la posizione dei match della ricerca.
# -z-5  : Scrolling mantenendo 5 righe.
LESS="-ciMRx4wJ -z-5"
PAGER=less
export LESS PAGER
# man page colorate SENZA usare most! ;-P
# http://nion.modprobe.de/blog/archives/572-less-colors-for-man-pages.html
## export LESS_TERMCAP_mb=$'\E[01;31m'
## export LESS_TERMCAP_md=$'\E[01;31m'
## export LESS_TERMCAP_me=$'\E[0m'
## export LESS_TERMCAP_se=$'\E[0m'
## export LESS_TERMCAP_so=$'\E[01;44;33m'
## export LESS_TERMCAP_ue=$'\E[0m'
## export LESS_TERMCAP_us=$'\E[01;32m'

# http://unix.stackexchange.com/questions/119/colors-in-man-pages
# export LESS_TERMCAP_mb=$(tput bold; tput setaf 2) # green
# export LESS_TERMCAP_md=$(tput bold; tput setaf 6) # cyan
# export LESS_TERMCAP_me=$(tput sgr0)
# export LESS_TERMCAP_so=$(tput bold; tput setaf 3; tput setab 4) # yellow on blue
# export LESS_TERMCAP_se=$(tput rmso; tput sgr0)
# export LESS_TERMCAP_us=$(tput smul; tput bold; tput setaf 7) # white
# export LESS_TERMCAP_ue=$(tput rmul; tput sgr0)
# export LESS_TERMCAP_mr=$(tput rev)
# export LESS_TERMCAP_mh=$(tput dim)
# export LESS_TERMCAP_ZN=$(tput ssubm)
# export LESS_TERMCAP_ZV=$(tput rsubm)
# export LESS_TERMCAP_ZO=$(tput ssupm)
# export LESS_TERMCAP_ZW=$(tput rsupm)

# da: http://linuxtidbits.wordpress.com/2009/03/23/less-colors-for-man-pages/
export LESS_TERMCAP_mb=$'\E[01;31m'       # begin blinking
export LESS_TERMCAP_md=$'\E[01;38;5;74m'  # begin bold
export LESS_TERMCAP_me=$'\E[0m'           # end mode
export LESS_TERMCAP_se=$'\E[0m'           # end standout-mode
export LESS_TERMCAP_so=$'\E[38;5;246m'    # begin standout-mode - info box
export LESS_TERMCAP_ue=$'\E[0m'           # end underline
export LESS_TERMCAP_us=$'\E[04;38;5;146m' # begin underline

# $EDITOR e $VISUAL
if (( $+commands[vim] )); then
	EDITOR=vim
	VISUAL=vim
else
	EDITOR=vi
	VISUAL=vi
fi
export EDITOR VISUAL

# `grep` options
# - grep colors (highlight verde)
# - skippa i file device, FIFO e socket.
export GREP_OPTIONS='--color=auto -D skip'
export GREP_COLOR='1;32'

# ssh-askpass, utility grafica
(($+commands[ssh-askpass] )) && export SSH_ASKPASS=ssh-askpass

# Controllo accessi al server
watch=(notme)
LOGCHECK=300		# check every 5 min for login/logout activity
WATCHFMT='%n %a %l from %m at %t.'

# PYTHONSTARTUP Ã¨ uno script che viene eseguito (a detta della man page) prima
# di avviare la modalitÃ  interattiva; mi Ã¨ perÃ² successo di essere root con
# questa variabile settata, e il file a cui puntava era leggibile solo da root,
# e facendo `su www-data -c "trac-admin ..."` (trac Ã¨ python) mi tornava errore
# perchÃ¨ non riusciva a leggere il file PYTHONSTARTUP, che ereditato da root
# puntava ancora a un file non leggibile da www-data.
# [[ -e ~/.pythonrc.py ]] && export PYTHONSTARTUP=~/.pythonrc.py
#
# Questa variabile dice all'interprete python di non scrivere file .py[co]
# PYTHONDONTWRITEBYTECODE="foo"
# }}}

# AUTOLOAD {{{
# --------
zmodload zsh/complist
zmodload zsh/pcre
# per ${terminfo}
# zmodload zsh/terminfo
# per 'strftime'
# zmodload zsh/datetime
# per 'syserorr'
# zmodload zsh/system

# Include in fpath e fa l'autoload delle funzioni zsh "locali". (da /usr/share/doc/zsh)
if [[ -d ~/.zsh/scripts ]]; then
	fpath=(~/.zsh/scripts $fpath)
	autoload -U ~/.zsh/scripts/*(:t)
fi

if [[ -d ~/.zsh/func ]]; then
	fpath=(~/.zsh/func $fpath)
fi

# Completion per task warrior
# NOTA: fpath va modificato PRIMA di chiamare 'compinit'.
[[ -e /usr/local/share/doc/task/scripts/zsh/_task ]] && fpath=($fpath /usr/local/share/doc/task/scripts/zsh/)
[[ -e /usr/share/doc/task/scripts/zsh/_task ]] && fpath=($fpath /usr/share/doc/task/scripts/zsh/)

# brew - zsh-completions
[[ -d /usr/local/share/zsh-completions/ ]] && fpath=(/usr/local/share/zsh-completions $fpath)

# elimina i duplicati da fpath
typeset -U fpath

# autoload mini-help
# -U also causes alias expansion to be suppressed  when  the  function is loaded
# The -k and -z flags make the function be loaded using  ksh-style  or
# zsh-style autoloading  respectively
### autoload -Uz compinit
### compinit
autoload -U zcalc zmv zargs
autoload -Uz url-quote-magic
zle -N self-insert url-quote-magic

# zsh-git
autoload -Uz vcs_info
zstyle ':vcs_info:*' actionformats \
	    '%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{3}|%F{1}%a%F{5}]%f'
zstyle ':vcs_info:*' formats       \
	    '%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{5}]%f'
zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'
zstyle ':vcs_info:*' enable git


# Other files
source $ZDOTDIR/bind
source $ZDOTDIR/cose
source $ZDOTDIR/alias
source $ZDOTDIR/zfunc
source $ZDOTDIR/work
# zcomp chiama compinit, percio' $fpath a questo punto deve essere quello DEFINITIVO
source $ZDOTDIR/zcomp
# solo shell interattive
[[ $- = *i* ]] && source $ZDOTDIR/welcome
[[ -e $ZDOTDIR/local ]] && source $ZDOTDIR/local

# Non mi piace, ma lo segno per il futuro.
## # zsh-mime-setup
## autoload -U zsh-mime-setup
## #zstyle :mime: mime-types /etc/mime.types
## zstyle :mime: mailcap ~/.mailcap /etc/mailcap
## zsh-mime-setup

# Colori
# [[ "${terminfo[colors]}" -ge 255 ]] && echo "256 colori!"

# }}}

# On-Line Help (accessibile con ESC+h in zle dopo aver digitato un comando,
# prima di premere return).
# Scaricare dal mirror gitweb di zsh lo script perl Utils/helpfiles, poi:
# mkdir ~/.zsh/help && cd ~/.zsh/help
# man zshall | colcrt -  | perl /path/to/helpfiles
# mirror: http://zsh.git.sourceforge.net/git/gitweb.cgi?p=zsh/zsh;a=blob_plain;f=Util/helpfiles;hb=HEAD
if [[ -d ~/.zsh/help ]]; then
	# ???
	# unalias run-help > /dev/null 2>&1
	unalias run-help
	autoload run-help
	HELPDIR=~/.zsh/help
fi

# Plugins
# NOTA: Alcuni tipo `zsh-syntax-highlight` vanno caricati alla *fine* del zshrc.
# zsh syntax highlight
if [[ -e $ZDOTDIR/plugins/zsh-synyax-highlighting.git/zsh-syntax-highlighting.zsh ]]; then
	ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor)
	source $ZDOTDIR/plugins/zsh-synyax-highlighting.git/zsh-syntax-highlighting.zsh
fi

# zsh Fish-style history search (va caricato DOPO zsh-syntax-highlight)
if [[ -e $ZDOTDIR/plugins/zsh-history-substring-search.git/zsh-history-substring-search.zsh ]]; then
	source $ZDOTDIR/plugins/zsh-history-substring-search.git/zsh-history-substring-search.zsh
fi

# zaw (dubbia utilita')
if [[ -e $ZDOTDIR/plugins/zaw.git/zaw.zsh ]]; then
	source $ZDOTDIR/plugins/zaw.git/zaw.zsh
fi

# Invece di `return 0` alla fine del file ci metto questo assignment, che
# dovrebbe essere equivalente in termini di "return OK".
FOO="grosso peto che esce dalle chiappe roboanti"
# Se per caso questo file esce con un valore diverso da zero, sara' PANDEMONIO!
# return 0
# vim: ft=zsh
