# +----------------------------------------------------------------------------+
# |                                                                            |
# |            ,@@@@@@@@@,                                                     |
# |          @@@@@@@@@@@@@@@    EHY PACE FRATELLO, QUESTO E' IL FILE PRINCIPALE|
# |         @@@@@@@@@@@@@@@@@   DI ZSH AMICO, NIENTE PRESE A MALE! FUMIAMOCI   |
# |         @@@@@@@@@@@@@@@@@   LA GANJA E FOTTIAMOCENE IL CAZZO DI TUTTO,     |
# |         @@@@@'_   _'@@@@@  /     DAI !                                     |
# |          @@@| o   o |@@@                                                   |
# |           '@|  (_)  |@'                                                    |
# |             \  ___  /                                                      |
# |             |\_`~`_/|            zsh/main (ex .zshrc)                      |
# |        ____/:  `"`  :\____       opzioni, prompt, PATH, defaults...        |
# |      /`}}}}}\       /{{{{{`\                                               |
# |     /  {{{{{ \     / }}}}}  \                                              |
# |    /   }}}}}  \.-./  {{{{{   \                                             |
# |   |    {{{{{  / | \  }}}}}    |                                            |
#jgs  |    }}}}}  \/|\/  {{{{{    |                                            |
# |   |   /{{{{{   '-'   }}}}}\   |                                            |
# +----------------------------------------------------------------------------+


# Questo file viene eseguito solo quando la shell e'
# interattiva, quindi NO script, NO crontab, SI sadomaso.

# Opzioni di zsh globali
source $ZDOTDIR/config


# PROMPT
# ----------------------------------------....
#                           )/_
#                 _.--..---"-,--c_
#            \L..'           ._O__)_
#    ,-.     _.+  _  \..--( /           a:f
#      `\.-''__.-' \ (     \_
#        `'''       `\__   /\
#                    ')

autoload -U colors
colors

# Hostname colorati in base al loro hash # idea copiata para para da
# nickcolors.pl per irssi
colnames=(
	black
	red
	green
	yellow
	blue
	magenta
	cyan
	white
	default
)

for color in $colnames; do
	eval f$color='%{${fg[$color]}%}'
	eval b$color='%{${bg[$color]}%}'
done

# zsh/spectrum
# http://github.com/sykora/etc/blob/master/zsh/functions/spectrum/
typeset -Ag FX FG BG

FX=(
    reset     "%{[00m%}"
    bold      "%{[01m%}" no-bold      "%{[22m%}"
    italic    "%{[03m%}" no-italic    "%{[23m%}"
    underline "%{[04m%}" no-underline "%{[24m%}"
    blink     "%{[05m%}" no-blink     "%{[25m%}"
    reverse   "%{[07m%}" no-reverse   "%{[27m%}"
)

for color in {000..255}; do
    FG[$color]="%{[38;5;${color}m%}"
    BG[$color]="%{[48;5;${color}m%}"
done

function spectrum_ls() {
	for code in {000..255}; do
		print -P -- "$code: %F{$code}Test%f"
	done
}


# Hash the hostname and return a fixed "random" color
function hostname_color() {
	local chash=0
	foreach letter ( ${(ws::)HOST[(ws:.:)1]} )
		(( chash += #letter ))
	end
	local crand=$(( $chash % 9 ))
	local crandname=$colnames[$crand]
	echo "%{${fg[$crandname]}%}"
}


#PROMPT='[%T] $(hostname_color)%m${fdefault}%(1j.|%j.):%3c%# '
PROMPT='${fblue}[%T] ${fyellow}%3~ ${vcs_info_msg_0_}
$(hostname_color)%n${fdefault}@$(hostname_color)%m${fdefault}%(1j.|%j.) %# '

# Metto in RPROMPT l'exit value dell'ultimo comando se non e' 0
RPROMPT=$'%(?..%B${fred}‚úò${fdefault} %?%b)'
# ci metto le info di git
#RPROMPT='${vcs_info_msg_0_}'

# Questo serve per costruire RPROMPT con le info di git
precmd () { vcs_info }

# Il prompt per lo spelling
# default: correct 'mano' to 'nano' [nyae]?
SPROMPT="zsh: correct '%R' to '%r' ? ([Y]es/[N]o/[E]dit/[A]bort) "

# NOTE PER IL PROMPT:
# - bisogna assegnare una stringa con apici SINGOLI, altrimenti le param. expansion NON funzionano!
# - come ${(%):-%~} ritorni $PWD a modo del prompt, e' MAGIA parameter expansion :)
## PROMPT='$FG[220][%T] in: $FX[bold]$FG[034]${${(%):-%~}//\//$FG[022]/$FG[034]}$FX[reset]%(0w#$FG[196] -> E DOMENICA! <-$FX[reset] #)
## %(1j.[%j] .)%(!.$FG[196]root .)$FG[245]%#$FX[reset] '

## RPROMPT="$FG[208]%n$FG[230]@$FG[075]%m$FX[reset]"

# Idee per path nel prompt colorato
# http://superuser.com/questions/49092/how-to-format-the-path-in-a-zsh-prompt

# MISC FUNCTIONS {{{
function exists { which $1 &> /dev/null }
# }}}

# ENVIRONMENT {{{
# -----------
# Queste variabili d'ambiente servono solo in modalita' interattiva
# Binda le seguenti variabili d'ambiente ai loro rispettivi array (ex: $perl5lib[@] )
declare -T LD_LIBRARY_PATH ld_library_path
declare -T PERL5LIB perl5lib
declare -T PYTHONPATH pythonpath

# La lingua tra le chiappe: LOCALE
# E' richiesto da iTerm (con UTF-8) e in generale e' il 2011 e direi che puo'
# anche diventare il mio cazzo di default.
# export LANG="en_US.UTF-8"
# !!! - 15 Nov 2011 - C'e' un po' di confusione, disattivo tutti i locale custom.
## export LANG="it_IT.UTF-8"
## export LC_MESSAGES="en_US.UTF-8"

# FTP in passive mode (CPAN)
export FTP_PASSIVE=1

# History
setopt append_history		# Appende al file $HISTORY, invece di sovrascrivere
setopt extended_history		# Salva i timestamp nella history
setopt hist_ignore_dups		# se il comando e' uguale al precedente non metterlo nella history
setopt hist_no_store		# non salvare nella history i comandi "history"
setopt hist_verify			# quando si usa la history expansion non esegue direttamente, cosi' vedi che stai per fare.
setopt hist_ignore_space	# non salva nella history le command line che iniziano con uno spazio (utile quando si inseriscono pw)
setopt hist_expire_dups_first	# cerca di cancellare dalla history i duplicati prima degli eventi unici
# February 21, 2013 - 2000 di history √® troppo poco, proviamo 12000 e vediamo
# che accade (che tra l'altro √® pi√π di prima :-)
SAVEHIST=10000
HISTSIZE=12000

#HISTSIZE=2000
# 18-07-2012 - Scopro che forse e' questa history IMMENSA che mi causa uno
# startup molto lento per le nuove shell. Molti lo tengono uguale a HISTSIZE,
# ma questo significa che a conti fatti nel file history ci sara' solo la
# history dell'ultima shell chiusa, se e' stata molto utilizzata.
# SAVEHIST=10000
#SAVEHIST=2000
HISTFILE=$HOME/.history

# Opzioni per less
# -c	: pulisce lo schermo prima di mostrare il file
# -i	: ignore case (ma una ricerca uppercase annulla l'opzione)
# -M	: mostra percentuale del file ed e' piu' verboso di more
# -R	: attiva i colori ANSI
# -x<n> : lunghezza del tab
# -w	: Temporarily highlights the first "new" line after a forward movement of a full page.
# -J    : Mostra una 'status column' che indica la posizione dei match della ricerca.
# -z-5  : Scrolling mantenendo 5 righe.
LESS="-ciMRx4wJ -z-5"
PAGER=less
export LESS PAGER
# man page colorate SENZA usare most! ;-P
# http://nion.modprobe.de/blog/archives/572-less-colors-for-man-pages.html
## export LESS_TERMCAP_mb=$'\E[01;31m'
## export LESS_TERMCAP_md=$'\E[01;31m'
## export LESS_TERMCAP_me=$'\E[0m'
## export LESS_TERMCAP_se=$'\E[0m'
## export LESS_TERMCAP_so=$'\E[01;44;33m'
## export LESS_TERMCAP_ue=$'\E[0m'
## export LESS_TERMCAP_us=$'\E[01;32m'

# http://unix.stackexchange.com/questions/119/colors-in-man-pages
# export LESS_TERMCAP_mb=$(tput bold; tput setaf 2) # green
# export LESS_TERMCAP_md=$(tput bold; tput setaf 6) # cyan
# export LESS_TERMCAP_me=$(tput sgr0)
# export LESS_TERMCAP_so=$(tput bold; tput setaf 3; tput setab 4) # yellow on blue
# export LESS_TERMCAP_se=$(tput rmso; tput sgr0)
# export LESS_TERMCAP_us=$(tput smul; tput bold; tput setaf 7) # white
# export LESS_TERMCAP_ue=$(tput rmul; tput sgr0)
# export LESS_TERMCAP_mr=$(tput rev)
# export LESS_TERMCAP_mh=$(tput dim)
# export LESS_TERMCAP_ZN=$(tput ssubm)
# export LESS_TERMCAP_ZV=$(tput rsubm)
# export LESS_TERMCAP_ZO=$(tput ssupm)
# export LESS_TERMCAP_ZW=$(tput rsupm)

# da: http://linuxtidbits.wordpress.com/2009/03/23/less-colors-for-man-pages/
# export LESS_TERMCAP_mb=$'\E[01;31m'       # begin blinking
# export LESS_TERMCAP_md=$'\E[01;38;5;74m'  # begin bold
# export LESS_TERMCAP_me=$'\E[0m'           # end mode
# export LESS_TERMCAP_se=$'\E[0m'           # end standout-mode
# export LESS_TERMCAP_so=$'\E[38;5;246m'    # begin standout-mode - info box
# export LESS_TERMCAP_ue=$'\E[0m'           # end underline
# export LESS_TERMCAP_us=$'\E[04;38;5;146m' # begin underline

# http://rawtec.de/dotfiles/bashrc.html
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

# $EDITOR e $VISUAL
if (( $+commands[vim] )); then
	EDITOR=vim
	VISUAL=vim
else
	EDITOR=vi
	VISUAL=vi
fi
export EDITOR VISUAL

# `grep` options
# - grep colors (highlight verde)
# - skippa i file device, FIFO e socket.
export GREP_OPTIONS='--color=auto -D skip'
export GREP_COLOR='1;32'

# ssh-askpass, utility grafica
(($+commands[ssh-askpass] )) && export SSH_ASKPASS=ssh-askpass

# Controllo accessi al server
watch=(notme)
LOGCHECK=300		# check every 5 min for login/logout activity
WATCHFMT='%n %a %l from %m at %t.'

# PRIVACY
# disattiva history del client mysql
export MYSQL_HISTFILE=/dev/null
export LESSHISTFILE=/dev/null

# PYTHONSTARTUP √® uno script che viene eseguito (a detta della man page) prima
# di avviare la modalit√† interattiva; mi √® per√≤ successo di essere root con
# questa variabile settata, e il file a cui puntava era leggibile solo da root,
# e facendo `su www-data -c "trac-admin ..."` (trac √® python) mi tornava errore
# perch√® non riusciva a leggere il file PYTHONSTARTUP, che ereditato da root
# puntava ancora a un file non leggibile da www-data.
# [[ -e ~/.pythonrc.py ]] && export PYTHONSTARTUP=~/.pythonrc.py
#
# Questa variabile dice all'interprete python di non scrivere file .py[co]
# PYTHONDONTWRITEBYTECODE="foo"
# }}}

# AUTOLOAD {{{
# --------
zmodload zsh/complist
# zmodload zsh/pcre
# per ${terminfo}
# zmodload zsh/terminfo
# per 'strftime'
# zmodload zsh/datetime
# per 'syserorr'
# zmodload zsh/system

# completion indicator
# source: https://github.com/mattjj/my-oh-my-zsh/blob/master/keyboard.zsh
zstyle ':omz:completion' indicator '...'

function expand-or-complete-prefix-with-indicator() {
  local indicator
  zstyle -s ':omz:completion' indicator 'indicator'
  print -Pn "$indicator"
  zle expand-or-complete-prefix
  zle redisplay
}
zle -N expand-or-complete-prefix-with-indicator

# Use human-friendly identifiers.
zmodload zsh/terminfo
typeset -g -A keyinfo
keyinfo=(
  'Control'   '\C-'
  'Escape'    '\e'
  'Meta'      '\M-'
  'F1'        "$terminfo[kf1]"
  'F2'        "$terminfo[kf2]"
  'F3'        "$terminfo[kf3]"
  'F4'        "$terminfo[kf4]"
  'F5'        "$terminfo[kf5]"
  'F6'        "$terminfo[kf6]"
  'F7'        "$terminfo[kf7]"
  'F8'        "$terminfo[kf8]"
  'F9'        "$terminfo[kf9]"
  'F10'       "$terminfo[kf10]"
  'F11'       "$terminfo[kf11]"
  'F12'       "$terminfo[kf12]"
  'Backspace' "$terminfo[kbs]"
  'Insert'    "$terminfo[kich1]"
  'Home'      "$terminfo[khome]"
  'PageUp'    "$terminfo[kpp]"
  'Delete'    "$terminfo[kdch1]"
  'End'       "$terminfo[kend]"
  'PageDown'  "$terminfo[knp]"
  'Up'        "$terminfo[kcuu1]"
  'Left'      "$terminfo[kcub1]"
  'Down'      "$terminfo[kcud1]"
  'Right'     "$terminfo[kcuf1]"
  'BackTab'   "$terminfo[kcbt]"
)

# Complete in the middle of word.
[[ -n "$keyinfo[Control]" ]] && \
    bindkey -M "emacs" "$keyinfo[Control]I" expand-or-complete-prefix

[[ -n "$keyinfo[Control]" ]] && \
    bindkey -M "emacs" "$keyinfo[Control]I" \
    expand-or-complete-prefix-with-indicator

# META+delete come in bash, invece che settare WORDCHARS
autoload -U select-word-style
select-word-style bash

# Include in fpath e fa l'autoload delle funzioni zsh "locali". (da /usr/share/doc/zsh)
typeset -U fpath

do_autoload () {
    if [[ -d $1 ]]; then
	fpath=($1 $fpath)
	autoload -U $1/*(:t)
    fi
}

do_autoload ~/.zsh/scripts
do_autoload ~/.zsh/functions

# Completion per task warrior
# NOTA: fpath va modificato PRIMA di chiamare 'compinit'.
[[ -e /usr/local/share/doc/task/scripts/zsh/_task ]] && fpath=($fpath /usr/local/share/doc/task/scripts/zsh/)
[[ -e /usr/share/doc/task/scripts/zsh/_task ]] && fpath=($fpath /usr/share/doc/task/scripts/zsh/)

# brew - zsh-completions
[[ -d /usr/local/share/zsh-completions/ ]] && fpath=(/usr/local/share/zsh-completions $fpath)

# autoload mini-help
# -U also causes alias expansion to be suppressed  when  the  function is loaded
# The -k and -z flags make the function be loaded using  ksh-style  or
# zsh-style autoloading  respectively
### autoload -Uz compinit
### compinit
autoload -U zcalc zmv zargs
autoload -Uz url-quote-magic
zle -N self-insert url-quote-magic

# zsh-git
autoload -Uz vcs_info
zstyle ':vcs_info:*' actionformats \
	    '%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{3}|%F{1}%a%F{5}]%f'
zstyle ':vcs_info:*' formats       \
	    '%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{5}]%f'
zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'
zstyle ':vcs_info:*' enable git


# Other files
source $ZDOTDIR/bind
source $ZDOTDIR/cose
source $ZDOTDIR/alias
source $ZDOTDIR/zfunc
# source $ZDOTDIR/work

# solo shell interattive
[[ $- = *i* ]] && source $ZDOTDIR/welcome

# zcomp chiama compinit, percio' $fpath a questo punto deve essere quello DEFINITIVO
source $ZDOTDIR/zcomp

# Settings locali
[[ -e $ZDOTDIR/local ]] && source $ZDOTDIR/local

# Non mi piace, ma lo segno per il futuro.
## # zsh-mime-setup
## autoload -U zsh-mime-setup
## #zstyle :mime: mime-types /etc/mime.types
## zstyle :mime: mailcap ~/.mailcap /etc/mailcap
## zsh-mime-setup

# Colori
# [[ "${terminfo[colors]}" -ge 255 ]] && echo "256 colori!"

# }}}

# On-Line Help (accessibile con ESC+h in zle dopo aver digitato un comando,
# prima di premere return).
# Scaricare dal mirror gitweb di zsh lo script perl Utils/helpfiles, poi:
# mkdir ~/.zsh/help && cd ~/.zsh/help
# man zshall | colcrt -  | perl /path/to/helpfiles
# mirror: http://zsh.git.sourceforge.net/git/gitweb.cgi?p=zsh/zsh;a=blob_plain;f=Util/helpfiles;hb=HEAD
if [[ -d ~/.zsh/help ]]; then
	# ???
	# unalias run-help > /dev/null 2>&1
	unalias run-help
	autoload run-help
	HELPDIR=~/.zsh/help
fi

# Plugins
# if [[ -e $ZDOTDIR/plugins/zsh-synyax-highlighting.git/zsh-syntax-highlighting.zsh ]]; then
# 	ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor)
# 	source $ZDOTDIR/plugins/zsh-synyax-highlighting.git/zsh-syntax-highlighting.zsh
# fi

# composure
# https://github.com/erichs/composure
### [[ -e $ZDOTDIR/plugins/composure.sh ]] && source $ZDOTDIR/plugins/composure.sh

# Invece di `return 0` alla fine del file ci metto questo assignment, che
# dovrebbe essere equivalente in termini di "return OK".
FOO="grosso peto che esce dalle chiappe roboanti"
# Se per caso questo file esce con un valore diverso da zero, sara' PANDEMONIO!
# return 0
# vim: ft=zsh
