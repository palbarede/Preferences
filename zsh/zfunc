# =====================================================================
# ~/.zsh/zfunc
# Funzioni per varie funzioni; essendo brevi non uso il metodo autoload
# ---------------------------------------------------------------------

# GRML - zsh-lovers
# zsh profiling {{{
# just execute 'ZSH_PROFILE_RC=1 zsh' and run 'zprof' to get the details
if [[ $ZSH_PROFILE_RC -gt 0 ]] ; then
    zmodload zsh/zprof
fi
# }}}

# Find history events by search pattern and list them by date.
whatwhen()  {
# {{{
    emulate -L zsh
    local usage help ident format_l format_s first_char remain first last
    usage='USAGE: whatwhen [options] <searchstring> <search range>'
    help="Use 'whatwhen -h' for further explanations."
    ident=${(l,${#${:-Usage: }},, ,)}
    format_l="${ident}%s\t\t\t%s\n"
    format_s="${format_l//(\\t)##/\\t}"
    # Make the first char of the word to search for case
    # insensitive; e.g. [aA]
    first_char=[${(L)1[1]}${(U)1[1]}]
    remain=${1[2,-1]}
    # Default search range is `-100'.
    first=${2:-\-100}
    # Optional, just used for `<first> <last>' given.
    last=$3
    case $1 in
        ("")
            printf '%s\n\n' 'ERROR: No search string specified. Aborting.'
            printf '%s\n%s\n\n' ${usage} ${help} && return 1
        ;;
        (-h)
            printf '%s\n\n' ${usage}
            print 'OPTIONS:'
            printf $format_l '-h' 'show help text'
            print '\f'
            print 'SEARCH RANGE:'
            printf $format_l "'0'" 'the whole history,'
            printf $format_l '-<n>' 'offset to the current history number; (default: -100)'
            printf $format_s '<[-]first> [<last>]' 'just searching within a give range'
            printf '\n%s\n' 'EXAMPLES:'
            printf ${format_l/(\\t)/} 'whatwhen grml' '# Range is set to -100 by default.'
            printf $format_l 'whatwhen zsh -250'
            printf $format_l 'whatwhen foo 1 99'
        ;;
        (\?)
            printf '%s\n%s\n\n' ${usage} ${help} && return 1
        ;;
        (*)
            # -l list results on stout rather than invoking $EDITOR.
            # -i Print dates as in YYYY-MM-DD.
            # -m Search for a - quoted - pattern within the history.
            fc -li -m "*${first_char}${remain}*" $first $last
        ;;
    esac
# }}}
}

xtrename() {
    emulate -L zsh
    if [[ $1 != "-f" ]] ; then
        if [[ -z ${DISPLAY} ]] ; then
            printf 'xtrename only makes sense in X11.\n'
            return 1
        fi
    else
        shift
    fi
    if [[ -z $1 ]] ; then
        printf 'usage: xtrename [-f] "title for xterm"\n'
        printf '  renames the title of xterm from _within_ screen.\n'
        printf '  also works without screen.\n'
        printf '  will not work if DISPLAY is unset, use -f to override.\n'
        return 0
    fi
    print -n "\eP\e]0;${1}\C-G\e\\"
    return 0
}

# It's shameless stolen from <http://www.vim.org/tips/tip.php?tip_id=167>
#f5# Use \kbd{vim} as your manpage reader
vman() {
    emulate -L zsh
    man $* | col -b | view -c 'set ft=man nomod nolist' -
}
# END OF GRML - zsh-lovers

# ZMV
# rinomina i file sostituendo con '_'
to_underscore() {
	zmv '(*) (*)' '$f:gs/ /_'
}
to_lower() {
	zmv '(*)' '${(L)1}'
}
to_upper() {
	zmv '(*)' '${(U)1}'
}

# Utile per i dotfiles
# zmv $HOME'/dotfiles/dot_(*)' '$HOME/$1'

# dopo anni, mkdir && cd ;-P
mcd () {
	mkdir "$@" && cd "$@"
}

# tree amanuense se non c'e' il pacchetto installato
# from strcat.de
if (( ! $+commands[tree] )); then
	tree() { find . | sed -e 's/[^\/]*\//|----/g' -e 's/---- |/    |/g' | $PAGER }
fi

restapache () {
	apachectl stop
	sleep 3
	print -l ${(M)${(f)"$(ps xauw)"}:#*(httpd|apache)*}
	#read -r 'res?Restarto? [yes/no]: '
	read -r "res?$fg_bold[green]Restarto? [$fg_bold[red]Yes$fg_bold[green]/$fg_bold[red]No$fg_bold[green]]$reset_color"
	if [[ $res = (#i)"yes" ]]; then apachectl start; fi
}

# hahahah http://www.strcat.de/dotfiles/zsh/dot.zshfunctions
dick() { uptime | perl -ne "/(\d+) d/;print 8,q(=)x\$1,\"D\n\"" }

# aggiunge una directory al $PATH
addpath() {
	if [[ -z $1 ]]; then
		echo "Usage: $0 <directory>"
		return 1
	fi
	path+=$1
	#path=( $path[@] $1 )
	rehash
}

# funzioni per settare TERM velocemente
# xt -> 'xterm'
# xtc -> 'xterm-color'
# xts -> 'screen'
xt() {
	[[ "$TERM" = 'xterm' ]] && return;
	export TERM=xterm
	echo "TERM changed to 'xterm'"
}
xtc() {
	[[ "$TERM" = 'xterm-color' ]] && return;
	export TERM=xterm-color
	echo "TERM changed to 'xterm-color'"
}
xts() {
	[[ "$TERM" = 'screen' ]] && return;
	export TERM=screen
	echo "TERM changed to 'screen'"
}

# mirror un sito web
suca() {
	if [[ -z "$1" ]]; then
		echo "$0 <url>"
		return 1
	fi
	wget -krmnp "$1"
}

# fa un po' di pulizia per la privacy...
privacy() {
	echo "+PRIVACY"
	if [[ ! -z $SSH_AGENT_PID ]]; then
		echo " killing ssh agent..."
		ssh-agent -k
	fi
	echo " deleting ~/.viminfo..."
	rm -f ~/.viminfo
	echo " deleting shell history..."
	unset HISTFILE
	echo "done."
}

pulisci() {
	echo "Deleting: (press enter or ctrl+c)"
	echo *~(.UGrw)
	read
	rm -f *~(.UGrw)
}

# chiavi ssh
chiavale() {
	keychain -q --inherit local ~/.ssh/*.pub(:r)
}

schiavale() {
	ssh-add -D
}

chiavi() {
	if [[ ! -z "$SSH_ASKPASS" ]]; then
		ssh-add ~/.ssh/*.pub(:r) < /dev/null
	else
		ssh-add ~/.ssh/*.pub(:r)
	fi
}

# XXX si puo' fare con il completion...
# cd nella dir con i log di cronolog di oggi
cdwww() {
	cd /var/log/apache/$(date +"%y/%m/%d")/
}

# Questa fantastica funzione cerca un file chiamato ~/.cvs_addrbook e se esiste,
# lo legge e crea funzioni zsh con i parametri letti:
# myhost :ext:cvs@host.net:/home/cvsroot
# creera' la funzione "cvs_myhost"
_cvsaddrbook () {
	[[ -e ~/.cvs_addrbook ]] || return
	lista=( ${(f)"$( < ~/.cvs_addrbook )"} )

	for i in $lista
	do
		eval "function cvs_${${(z)i}[1]} () {
			export CVSROOT=${${(z)i}[2]}
			echo export CVSROOT=${${(z)i}[2]}
		}
		"
	done
}

# Basta eseguirla una sola volta...
_cvsaddrbook

# dovessi mai usare tar per copiare...
copiatar () {
	echo "tar cvf - . | ( cd /altrove; tar xvf - )"
}

# sfortune cerca prima i miei fortune e poi quelli
# di sistema
sfortune () {
	if [[ -e ~/.fortune ]]; then
		if (( $+commands[cowsay] )); then
			cowsay `fortune -ae ~/.fortune/*~*.dat`
		else
			print;$cowsay fortune -ae ~/.fortune/*~*.dat;print
		fi
	else
		print;fortune -ae;print
	fi
}

obsd_cvslist () {
	if (( ! $+commands[curl] )); then
		echo "You need 'curl' to run this. pkg_add -i curl"
		return
	fi
	CVSURL="http://www.openbsd.org/anoncvs.html"

	for cvsroot in $(curl -s ${CVSURL} | grep "CVSROOT=" | cut -d">" -f3- | cut -d"<" -f1); do
		echo "$cvsroot"
	done
}

obsd_ftplist () {
	if (( ! $+commands[curl] )); then
		echo "You need 'curl' to run this. pkg_add -i curl"
		return
	fi
	MIRRORURL="http://www.openbsd.org/ftp.html"

	for mirror in $(curl -s ${MIRRORURL} | egrep -i "<a.*(http|ftp)://.*openbsd" | cut -d'"' -f2); do
		echo "$mirror"
	done
}

# rigenera le versioni compilate degli script 
rifaitutto () {
	# Al contrario di quanto credevo, eseguire questi comandi all'avvio (.zshrc)
	# rallenta di molto lo startup della shell.
	autoload -U zrecompile
	zrecompile -qp \
		-R ${ZDOTDIR}/.zshrc -- \
		-R ${HOME}/.zshenv -- \
		-R ${ZDOTDIR}/bind -- \
		-R ${ZDOTDIR}/cose -- \
		-R ${ZDOTDIR}/os/darwin -- \
		-R ${ZDOTDIR}/os/linux -- \
		-R ${ZDOTDIR}/os/openbsd -- \
		-R ${ZDOTDIR}/os/solaris -- \
		-R ${ZDOTDIR}/zcomp -- \
		-R ${ZDOTDIR}/alias -- \
		-R ${ZDOTDIR}/zfunc -- \
		-R ${ZDOTDIR}/welcome -- \
		-M ${ZDOTDIR}/.zcompdump
}

# lista i file in ordine di grandezza
bysize () {
	if [[ -z $1 ]]; then
		ls -flh *(.oL)
	else
		ls -flh $1/*(.oL)
	fi
}

raw_kb () {
	echo "Type your keys, then ^D to quit"
	tput smkx && cat; tput rmkx && echo "done"
}

ssh_bg () {
	echo "ssh -f -L 6667:localhost:6667 hostname sleep 60"
	echo "- sleep 60 indica il tempo che ssh aspettera' per connessioni sulla porta prima di morire"
}

nssh () {
    screen -t $*[$#] ssh $*
}

piugrandi () {
    echo ls -fldh ./**/*(d`stat +device .`OL[1,10])
}

rscreen () {
    autossh -t $1 "screen -e^Ff -daAR"
}

# da oh-my-zsh
function zsh_stats() {
  history | awk '{print $2}' | sort | uniq -c | sort -rn | head
}

# vim: ft=zsh
