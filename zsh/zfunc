# =====================================================================
# ~/.zsh/zfunc
# Funzioni per varie funzioni; essendo brevi non uso il metodo autoload
# ---------------------------------------------------------------------

# GRML - zsh-lovers
# zsh profiling {{{
# just execute 'ZSH_PROFILE_RC=1 zsh' and run 'zprof' to get the details
if [[ $ZSH_PROFILE_RC -gt 0 ]] ; then
    zmodload zsh/zprof
fi
# }}}

# vim per leggere le pagine man {{{
# It's shameless stolen from <http://www.vim.org/tips/tip.php?tip_id=167>
#f5# Use \kbd{vim} as your manpage reader
vman() {
    emulate -L zsh
    man $* | col -b | view -c 'set ft=man nomod nolist' -
}
mann () {
    vim -c "runtime ftplugin/man.vim" -c "Man ${1-man}" +"wincmd o"
}

triman () {
    if [[ $# -eq 0 ]]; then
	man
    elif whatis $* ; then
	man $* | col -bp | iconv -c | view -c 'set ft=man nomod nolist' -
    fi
}
# END OF GRML - zsh-lovers
# }}}

# Fetcha una copia della pagina zsh-lovers
zsh_lovers_fetch() {
	curl http://grml.org/zsh/zsh-lovers.html
}

# ZMV {{{
# rinomina i file sostituendo con '_'
to_underscore() {
	zmv '(*) (*)' '$f:gs/ /_'
}
to_lower() {
	zmv '(*)' '${(L)1}'
}
to_upper() {
	zmv '(*)' '${(U)1}'
}
# }}}

# Utile per i dotfiles
# zmv $HOME'/dotfiles/dot_(*)' '$HOME/$1'

# dopo anni, mkdir && cd ;-P {{{
mcd () {
	mkdir -p "$@" && cd "$@"
}
# }}}

# tree amanuense se non c'e' il pacchetto installato {{{
# from strcat.de
if (( ! $+commands[tree] )); then
	tree() { find . | sed -e 's/[^\/]*\//|----/g' -e 's/---- |/    |/g' | $PAGER }
fi
# }}}

# hahahah http://www.strcat.de/dotfiles/zsh/dot.zshfunctions
dick() { uptime | perl -ne "/(\d+) d/;print 8,q(=)x\$1,\"D\n\"" }

# aggiunge una directory al $PATH
addpath() {
	if [[ -z $1 ]]; then
		echo "Usage: $0 <directory>"
		return 1
	fi
	path+=$1
	#path=( $path[@] $1 )
	rehash
}

# funzioni per settare TERM velocemente
# xt -> 'xterm'
# xtc -> 'xterm-color'
# xts -> 'screen'
xt() {
	[[ "$TERM" = 'xterm' ]] && return;
	export TERM=xterm
	echo "TERM changed to 'xterm'"
}
xtc() {
	[[ "$TERM" = 'xterm-color' ]] && return;
	export TERM=xterm-color
	echo "TERM changed to 'xterm-color'"
}
xts() {
	[[ "$TERM" = 'screen' ]] && return;
	export TERM=screen
	echo "TERM changed to 'screen'"
}

# mirror un sito web
suca() {
	if [[ -z "$1" ]]; then
		echo "$0 <url>"
		return 1
	fi
	wget -krmnp "$1"
}

# fa un po' di pulizia per la privacy...
privacy() {
	echo "+PRIVACY"
	if [[ ! -z $SSH_AGENT_PID ]]; then
		echo " killing ssh agent..."
		ssh-agent -k
	fi
	echo " deleting ~/.viminfo..."
	rm -f ~/.viminfo
	echo " deleting shell history..."
	unset HISTFILE
	echo "done."
}

pulisci() {
	echo "Deleting: (press enter or ctrl+c)"
	echo *~(.UGrw)
	read
	rm -f *~(.UGrw)
}

# chiavi ssh
chiavale() {
	keychain -q --inherit local ~/.ssh/*.pub(:r)
}

schiavale() {
	ssh-add -D
}

chiavi() {
	if [[ ! -z "$SSH_ASKPASS" ]]; then
		ssh-add ~/.ssh/*.pub(:r) < /dev/null
	else
		ssh-add ~/.ssh/*.pub(:r)
	fi
}

# XXX si puo' fare con il completion...
# cd nella dir con i log di cronolog di oggi
cdwww() {
	cd /var/log/apache/$(date +"%y/%m/%d")/
}

# Questa fantastica funzione cerca un file chiamato ~/.cvs_addrbook e se esiste,
# lo legge e crea funzioni zsh con i parametri letti:
# myhost :ext:cvs@host.net:/home/cvsroot
# creera' la funzione "cvs_myhost"
_cvsaddrbook () {
	[[ -e ~/.cvs_addrbook ]] || return
	lista=( ${(f)"$( < ~/.cvs_addrbook )"} )

	for i in $lista
	do
		eval "function cvs_${${(z)i}[1]} () {
			export CVSROOT=${${(z)i}[2]}
			echo export CVSROOT=${${(z)i}[2]}
		}
		"
	done
}

# Basta eseguirla una sola volta...
_cvsaddrbook

# dovessi mai usare tar per copiare...
copiatar () {
	echo "tar cvf - . | ( cd /altrove; tar xvf - )"
}

# copia pv
# % (tar cf - files.* | pv -n -s $(gdu -csb files.* | tail -1 | awk '{print $1}') | (cd /Volumes/Expansion\ Drive; tar xf - )) 2>&1 | dialog --gauge 'Progress' 7 70

# sfortune cerca prima i miei fortune e poi quelli
# di sistema
sfortune () {
	if [[ -e ~/.fortune ]]; then
		if (( $+commands[cowsay] )); then
			cowsay `fortune -ae ~/.fortune/*~*.dat`
		else
			print;$cowsay fortune -ae ~/.fortune/*~*.dat;print
		fi
	else
		print;fortune -ae;print
	fi
}

# rigenera le versioni compilate degli script 
rifaitutto () {
	# Al contrario di quanto credevo, eseguire questi comandi all'avvio (.zshrc)
	# rallenta di molto lo startup della shell.
	autoload -U zrecompile
	zrecompile -qp \
		-R ${ZDOTDIR}/.zshrc -- \
		-R ${HOME}/.zshenv -- \
		-R ${ZDOTDIR}/bind -- \
		-R ${ZDOTDIR}/cose -- \
		-R ${ZDOTDIR}/os/darwin -- \
		-R ${ZDOTDIR}/os/linux -- \
		-R ${ZDOTDIR}/os/openbsd -- \
		-R ${ZDOTDIR}/os/solaris -- \
		-R ${ZDOTDIR}/zcomp -- \
		-R ${ZDOTDIR}/alias -- \
		-R ${ZDOTDIR}/zfunc -- \
		-R ${ZDOTDIR}/welcome -- \
		-M ${ZDOTDIR}/.zcompdump
}

# lista i file in ordine di grandezza
bysize () {
	if [[ -z $1 ]]; then
		ls -flh *(.oL)
	else
		ls -flh $1/*(.oL)
	fi
}

raw_kb () {
	echo "Type your keys, then ^D to quit"
	tput smkx && cat; tput rmkx && echo "done"
}

ssh_bg () {
	echo "ssh -f -L 6667:localhost:6667 hostname sleep 60"
	echo "- sleep 60 indica il tempo che ssh aspettera' per connessioni sulla porta prima di morire"
}

nssh () {
    screen -t $*[$#] ssh $*
}

piugrandi () {
    echo ls -fldh ./**/*(d`stat +device .`OL[1,10])
}

rscreen () {
    autossh -t $1 "screen -e^Ff -daAR"
}

# da oh-my-zsh
function zsh_stats() {
  history | awk '{print $2}' | sort | uniq -c | sort -rn | head
}

# irssi tmux e nicklist
irssi_tmux () {
	tmux split-window -h -l 12 'cat ~/.irssi/nicklistfifo'
	tmux select-pane -t 0
	irssi $@
}

# Notifiche di irssi remoto in Growl o Notification Center (OSX)
# - per growl usare growl-notify.
irssi_growl() {
	ssh spatof 'echo -n "" > ~/.irssi/fnotify; tail -f ~/.irssi/fnotify' | while read heading message; do ~/Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier -title \"$heading\" -message \"$message\"; done
}

estrai_bz2() {
	if [[ -z $1 ]]; then
		echo "Usage: estrai_bz2 <filename.bz2>"
		return
	fi
	if [[ ! $1 == *.bz2 ]]; then
		echo "ERRORE: il filename deve avere l'estensione .bz2"
		return
	fi

	out=${1/.bz2/}
	if (( $+commands[apv] )); then
		pv $1 | bzip2 -d > $out
	else
		echo "Running without the awesome 'pv' utility :-("
		bzip2 -cd $1 > $out
	fi
}

# IDEE
#
# Questo setta uno style
zstyle ":chpwd:profiles:${HOME}/Work(|/|/*)" profile work

# Questo controlla se esiste uno style corrispondente
function controlla() {
	local -x profile

	zstyle -s ":chpwd:profiles:${PWD}" profile profile || profile='default'
	print $profile
}
# controlla

# setta il titolo su tmux
settitle() {
	printf "\033k$1\033\\"
}

# anti tar bomb
# NOTA: deprecated, meglio usare `atool` (aunpack, als, etc.)
sbomba() {
	l=$(tar tf $1)
	if [[ ${#${(f)l}} -eq $(echo "$l" | grep ${${(f)l}[1]} | wc -l) ]]; then
		tar xf $1
	else
		mkdir ${1%.t(ar.gz||ar.bz2||gz||bz||ar)} && tar xvf $1 -C ${1%.t(ar.gz||ar.bz2||gz||bz||ar)}
	fi
}

# ssh wrapper that rename current tmux window to the hostname of the
# remote host.
ssh() {
	# Do nothing if we are not inside tmux
	if [[ -z $TMUX ]]; then
		command ssh $@
		return
	fi
	# The hostname is the last parameter (i.e. ${(P)#})
	local hostname=${${(P)#}%.*}
	# Save the current name
	local old_name="$(tmux display-message -p '#W')"
	if [[ $hostname != -* ]]; then
		tmux rename-window $hostname
	fi
	command ssh $@
	tmux rename-window "$old_name"
}

# vim: ft=zsh
